# 代码随想录学习笔记

## 字符串

### 实现字符串内查找模型字符串（KMP算法）

> 题目：给你两个字符串`haystack`和`needle`，请你在`haystack`字符串中找出`needle`字符串的第一个匹配项的下标（下标从 0 开始）。如果`needle`不是`haystack`的一部分，则返回-1 。

[力扣题目链接](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

#### PMT（部分匹配表）
对于任意长度的字符串，都有数个前缀集合和后缀集合，**PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度**。
>如：对于‘aba’，它的前缀集合为{‘a’, ‘b’}，后缀 集合为{‘ba’, ‘a’}。两个集合的交集为{‘a’}，那么长度最长的元素就是字符串‘a’了，长度为1，所以对于‘aba’而言，它在PMT表中对应的值就是1。对于字符串‘ababa’，它的前缀集合为{‘a’, ‘ab’, ‘aba’, ‘abab’}，它的后缀集合为{‘baba’, ‘aba’, ‘ba’, ‘a’}，两个集合的交集为{‘a’, ‘aba’}，其中最长的元素为‘aba’，长度为3。

#### PMT对于字符串查找的帮助
主字符串中 i 指针之前的 PMT[j−1]位就一定与模式字符串的第0位至第PMT[j−1]位是相同的。这是因为主字符串在i位失配，也就意味着主字符串从 i−j 到 i 这一段是与模式字符串的 0 到 j 这一段是完全相同的。

![KMP算法1](img/KMP算法1.jpg)
>如图所示，在字符串“ababab”中，最大相等前后缀为‘abab’，故对应的PMT值即为4。当 j 指针移动到‘c’时，i 和 j 对应的值不再相等，故j需要寻找前一个元素所对应的PMT值，即为4，这意味着在‘ababab’中，前半部分的‘abab’和后半部分的‘abab’是等价的，不需要重新判别一次。故 j 指针可以直接回退到PMT值所对应的下标（在本例中是4）。

#### next数组
由于在第 j 位失配实际上需要的是第 j-1 位的PMT值，所以编程中不直接使用PMT数组，而是将其整体右移一位，第0位设置为-1，得到next数组。
**构建next数组的过程**：利用双指针法，比较慢指针s[j+1]与快指针s[i]，如果两者不等，则 j 需要回退：**j=next[j]**，若相等则两者同时前进，并把 j 赋给next[i]：**next[i]=j**。

#### 利用next数组匹配字符串
j从-1，i从0开始遍历，比较s[i]与t[j+1]，如果两者不等则j利用next数组回退：**j=next[j]**，若相等则同时向后移动。如果 j 指向了模式串 t 的末尾，那么就说明模式串 t 完全匹配文本串 s 里的某个子串了。

参考资料：(https://www.zhihu.com/question/21923021/answer/281346746)

### 重复的子字符串

> 题目：给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

[力扣题目链接](https://leetcode.cn/problems/repeated-substring-pattern/description/)

#### 移动匹配
一个由多个子串重复组成的字符串s，对于s+s，中间部分一定能够组成出一个新的字符串  s。相对地，如果中间能够组成出字符串`s`，则其一定是一个由多个子串重复组成的字符串。
为了防止在s+s中寻找到最初的两个s，需要对其进行“掐头去尾”：去掉该字符串中第一个和最后一个字符。之后在其中寻找s即可。（寻找过程本质上使用了KMP算法）

#### 使用KMP算法
结论1（充分性）：**如果一个字符串s是由重复子串组成，那么最长相等前后缀不包含的子串一定是字符串s的最小重复子串。**
结论2（必要性）：**当最长相等前后缀不包含的子串的长度可以被字符串s的长度整除，那么不包含的子串就是s的最小重复子串。**

如果`next[len-1] != -1`，则说明字符串存在最长相同的前后缀。
最长相等前后缀的长度为：`next[len-1] + 1`。
则字符串中最长相等前后缀不包含的子串的长度为`len - (next[len-1] + 1)`。
如果`len % (len - (next[len-1] + 1)) == 0`，则说明可以整除，字符串s是重复字符串。

![重复的子字符串](img/459.重复的子字符串_1.png)
>`next[len - 1] = 7`，`next[len - 1] + 1 = 8`，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。
>`(len - (next[len - 1] + 1))` 也就是：12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 为最长相同前后缀不包含的子串长度
>4可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。