# 代码随想录学习笔记

## 字符串

### 实现字符串内查找模型字符串（KMP算法）

> 题目：给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。

[力扣题目链接](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

#### PMT（部分匹配表）
对于任意长度的字符串，都有数个前缀集合和后缀集合，**PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度**。
>如：对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}，两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。

#### PMT对于字符串查找的帮助
主字符串中 i 指针之前的 PMT[j −1]位就一定与模式字符串的第0位至第PMT[j−1]位是相同的。这是因为主字符串在 i 位失配，也就意味着主字符串从i−j到i这一段是与模式字符串的0到j这一段是完全相同的。

#### next数组
由于在第j位失配实际上需要的是第j-1位的PMT值，所以编程中不直接使用PMT数组，而是将其整体右移一位，第0位设置为-1，得到next数组。
**构建next数组的过程**：利用双指针法，比较慢指针s[j+1]与快指针s[i]，如果两者不等，则j需要回退：**j=next[j]**，若相等则两者同时前进，并把j赋给next[i]：**next[i]=j**。

#### 利用next数组匹配字符串
j从-1，i从0开始遍历，比较s[i]与t[j+1]，如果两者不等则j利用next数组回退：**j=next[j]**，若相等则同时向后移动。如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。